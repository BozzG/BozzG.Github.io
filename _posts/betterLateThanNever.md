## Better Late Than Never  
#### 慢慢积累

1. hashmap
hashmap的实现就是数组加链表；
通过对key进行hash，得到一个索引值；
发生碰撞时(hash值相等)就通过链表的形式添加上去；
用的是头插入，因为设计者觉得后插入被查询的机会更好；
索引值计算是key的hash值对hashmap的初始长度求余，实现是hash值和length-1作与运算；
因此length默认取16并且，手动配置或自动扩大时也是取2的幂，以此保证hash的分布是均匀的
重哈希(rehash)，当hashmap的大小到一定地步就是进行，size >= capacity * loadfactor
hashmap线程不安全体现在，在重哈希过程中，如果同时put，有可能会形成链表环，get一个不存在的key时，会形成死循环，要避免可以使用ConcurrentHashMap

2. 动态规划
三要素：最优子结构、边界、状态转移公式

3. 红黑树
是一种自平衡二叉搜索树，是为了克服二叉搜索树左右不对称的情况；
红黑树规则
（１）节点非黑即红
（２）根节点为黑
（３）每个叶子都是黑的空节点
（４）红节点的两个子节点都为黑，即不存在连续两个红
（５）所有路径的黑节点数目相等
上面规则保证了，最长路径不会超过最短路径的２倍
自平衡操作：变色和选择

4. 双重检测机制
应用场景：单例模式new对象的时候，写缓存

5. LRU算法
长期不被使用的，以后也会用得少
实现上使用了哈希链表（以一对kv为节点的双向链表），被访问的加到队尾

6. B-树
数据库索引用树结构存储的原因是考虑到IO问题

7. volatile关键字
表示时随时变化的，每次读都要从内存中读，并且处理完马上写回内存
关键字作用是防止优化编译器把变量从内存装入CPU寄存器中
核心就是使用了这种关键字的变量，计算时不用寄存器中的数据，有点不用缓存直接读写数据库的意思
几个特性：
（１）　易变性
（２）　顺序性
（３）　不可优化性

8. mysql优化
（１）看执行计划
（２）字段设计和数据类型优化（建表阶段）
（３）创建高性能索引（建表阶段或者后面都可以）
（４）索引相关的数据结果和算法

9. 手写String

10. 单例模式实现
（１）构造函数私有，就可以禁止他人创建对象，但是Java的话可以通过反射强行创建，可以用枚举
（２）维护一个静态实例，创建实例的时机，分懒汉模式和饿汉模式
（３）要考虑多线程状态下，创建实例，要保证实例唯一

11. 全排列
实现：换位＋递归
















